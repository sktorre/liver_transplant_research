---
title: "Modeling"
author: "Sarah Torrence"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    number_sections: true
  html_notebook:
    fig_caption: yes
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F, error = F)
knitr::opts_chunk$set(fig.width=9, fig.height=6, fig.align = "center")

# Box access
library(boxr)
box_auth()

library(ggplot2)
library(rms)
library(tidyverse)

#read in data
data <- box_read("936748103348")
```

## Cleaning up Data Types

```{r}
convert <- c('ascites_yn', 'he', 'race', 'sex', 'smoker', 'etiology', 'acr',
             'newmalignancy', 'readmissionwithin90d',
             'infection_90', 'need_repeat_surgery',
             'vascularcomplicationswithin90days', 'biliarycomplication',
             'location_dc','htn', 'dm', 'ckd', 'ctd')

for (var in convert){
  data[var] <- as.factor(data[[var]])
}

data$state <- factor(data$state,
levels = c(1,2,3,4),
labels = c("Home/IPR", "Hospital", "ICU", "Dead"))

data$prev_state <- factor(data$prev_state,
levels = c(1,2,3,4),
labels = c("Home/IPR", "Hospital", "ICU", "Dead"))

#filtering out day 0 with no previous state
data <- data %>% filter(!is.na(prev_state))

datad <- datadist(data)
options(datadist="datad")
```

## Event Chart

Here is an event chart for a random sample of patients, removing all days post death if this state occurs in the random sample.

```{r}
set.seed(465)
ssamp <- sample(unique(data$patient_mrn), 65, FALSE)
dr <- subset(data, patient_mrn %in% ssamp)
dr <- subset(dr, state != 'Dead')
dr <- subset(dr, time <= 30)
dr$id <- as.integer(as.factor(dr$patient_mrn))
dr$status <- factor(dr$state, levels=rev(levels(dr$state)))
dr$time <- dr$time - 1
multEventChart(status ~ time + id, data=dr,
               absorb='Dead', sortbylast = TRUE) +
  theme_classic() +
  theme(legend.position='bottom')
```

## Checking the Proportional Odds Assumption

```{r}
d <- data %>% filter(time < 27)

propsTrans(state ~ time + patient_mrn, data=d, maxsize=6) +
  theme(legend.position='bottom', axis.text.x=element_text(angle=90, hjust=1))
```

### Proportional of each state estimated from day 1

```{r}
propsPO(state ~ time, data=d, nrow=1) +
  theme(legend.position='bottom', axis.text.x=element_text(angle=90, hjust=1))
```

```{r}
f <- lrm(state ~ rcs(time, 5), data=d)
g <- Function(f)   # derive predicted log odds as a function of day
# Make another function that gets the OR vs. day=1
dor <- function(time) exp(g(time) - g(3))
propsPO(state ~ time, odds.ratio=dor, data=d) +
  theme(legend.position='bottom')
```

```{r}
dd <- subset(d, prev_state != 'Dead')
f <- lrm(state ~ rcs(time, 5), data=dd)
g <- Function(f)   # derive predicted log odds as a function of day
# Make another function that gets the OR vs. day=1
dor <- function(time) exp(g(time) - g(1))
propsPO(state ~ time, odds.ratio=dor, data=dd) +
  theme(legend.position='bottom')
```

### Estimated starting at day 10

```{r}
dor <- function(time) exp(g(time) - g(10))
propsPO(state ~ time, odds.ratio=dor, ref=10, data=dd) +
  theme(legend.position='bottom')
```


## Allocating DF to predictors

```{r}
col_names <- colnames(data %>% select(-state, -patient_mrn))
formula <- as.formula(paste0("state ~ ",paste0(col_names,collapse = "+")))
s <- spearman2(formula ,data=d, p=2)
plot(s)
```

`prev_state`, `time`, `location_dc`, `dayson_ventpost_lt` and `meld` have the highest $\rho^2$. I can allocate more df to these variables, specifically using splines for `time`, `dayson_ventpost_lt` and `meld`.

## Model

```{r}
f <- lrm(state ~ ctd + (sex + age + sma00)^2 - age:sma00 + height + weight + ascites_yn + he +
           race + smoker + cit + dri + etiology + rcs(meld,3) + acr + newmalignancy + 
    surgeryduration + readmissionwithin90d + infection_90 + need_repeat_surgery + 
    vascularcomplicationswithin90days + rcs(vat00,3) + rcs(sat00,3) + 
    rcs(s_mhu00,3) + rcs(v_fhu00,3) + rcs(sa_thu00,3) + biliarycomplication + location_dc + 
    rcs(dayson_ventpost_lt,3) + htn + dm + ckd + rcs(time,5) + prev_state, data=d,
    x=TRUE, y=TRUE)
f
```


```{r}
g <- robcov(f, d$patient_mrn)
plot(anova(g), trans=sqrt)
```

## Reduce Model

**fast backwards** - should also take out other variables as well probably

```{r}
print(fastbw(f, rule=c('p')), estimates=FALSE)
```

validate model - boostrap
penalize variable selection

```{r, cache-TRUE}
set.seed(2022)
v <- validate(f, B=200, bw=TRUE, estimates=FALSE, rule='p')
v
```


Slope is percent of how much overfitting. and look at optimism? 

Standard errors will be too small because we don't correct for variable selection (confidence intervals will be too small)


```{r}
an <- anova(f)
print(an)

# how much variance explained would be chi-squared/total chi-squared shows approximately how much variance is explained by that parameter
```

Adding body composition as a chunk test to get the combined effect of body composition.

```{r}
b <- anova(f, sma00, vat00, sat00, s_mhu00, v_fhu00, sa_thu00)
s <- rbind(an, body_comp=b['TOTAL', ])
class(s) <- 'anova.rms'
plot(s)
```

### Partial Effect plot (mean scale)

```{r}
ggplot(Predict(f))

#ggplot(Predict(f, ref.zero=TRUE), vnames=’names’, sepdiscrete=’vertical’, anova=a)

#y axis log odds - if convert this get the median state value i think??
```

### Interpreting Predictions

```{r}
M <- Mean(f, codes=TRUE)
#qu <- Quantile(f, codes=TRUE)
med <- function(lp) qu(.5, lp)
q90 <- function(lp) qu(.9, lp)
lp <- Predict(f)
lpr <- quantile(predict(f), c(.002, .998), na.rm=TRUE)
lps <- seq(lpr[1], lpr[2], length=200) 
pmn <- M(lps)
#pme <- med(lps)
#p90 <- q90(lps)
```

```{r}
head(lp)
```


### Nomogram

```{r}
#n <- nomogram(f)
#plot(n)
```

